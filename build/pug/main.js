/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/pug-loader/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/pug-loader/i18n.js":
/*!********************************!*\
  !*** ./src/pug-loader/i18n.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function () {\n    'use strict';\n\n    /**\n     *\n     * To add a language, call i18n.add('language-code', {translation}, {options})\n     * Where options takes the following keys:\n     * \"plural\": function that takes a number, and returns a key suffix for plural form of that count.\n     * \"decimal\": decimal separator character. The default is auto-detected from the browser locale\n     * \"thousands\": thousands separator character. The default is auto-detected from the browser locale\n     *\n     */\n\n    /** @const */\n    var DEFAULT_DECIMAL_SEPARATOR = (1.1).toLocaleString().substr(1, 1);\n\n    /** @const */\n    var DEFAULT_THOUSANDS_SEPARATOR = (1000).toLocaleString().length === 5\n        ? (1000).toLocaleString().substr(1, 1)\n        : (DEFAULT_DECIMAL_SEPARATOR === ',' ? '.' : ',');\n\n    /** @const */\n    var DEFAULT_DECIMAL_SEPARATOR_REGEX = new RegExp('\\\\' + DEFAULT_DECIMAL_SEPARATOR, 'g');\n\n    var activeLanguage = '';\n    var fallbackLanguage = '';\n    var active = null;\n    var locs = {}; // Here we will keep i18n objects, each key is a language code\n    var originalLocs = {}; // Here we will keep original localizations before using extendLanguage\n\n    var _escapeRgx = /([\\/()[\\]?{}|*+-\\\\:])/g;\n    var regexEscape = function (string) {\n        return string.replace(_escapeRgx, '\\\\$1');\n    };\n    var arrayIndexOf = function (array, searchElement, fromIndex) {\n        var k, o = array;\n        var len = o.length >>> 0;\n        if (len === 0) {\n            return -1;\n        }\n        var n = +fromIndex || 0;\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n        if (n >= len) {\n            return -1;\n        }\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n        while (k < len) {\n            if (k in o && o[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n\n    /**\n     * The default plural form specifier.\n     * This function returns a specifier for plural form, for the specified count.\n     * @param {Number} count the number that we need to inspect\n     * @returns {string}\n     */\n    var defaultPlural = function (count) {\n        if (count == 0) return 'zero';\n        if (count == 1) return 'one';\n        return 'plural';\n    };\n\n    /**\n     * Encodes the value {value} using the specified {encoding}\n     * @param {String} value the value to encode\n     * @param {String} encoding for filters\n     * @returns {*}\n     */\n    var encodeValue = function (value, encoding) {\n        if (encoding === 'html') {\n            value = (value == null ? '' : (value + '')).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&#39;\").replace(/\"/g, \"&quot;\");\n        } else if (encoding === 'htmll') {\n            value = (value == null ? '' : (value + '')).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&#39;\").replace(/\"/g, \"&quot;\").replace(/\\n/g, \"<br />\");\n        } else if (encoding === 'json') {\n            value = JSON.stringify(value);\n        } else if (encoding === 'url') {\n            value = encodeURIComponent(value);\n        } else if (encoding === 'lower') {\n            value = (value + '').toLowerCase();\n        } else if (encoding === 'upper') {\n            value = (value + '').toUpperCase();\n        } else if (encoding === 'upperfirst') {\n            value = value + '';\n            value = value[0].toUpperCase() + value.substr(1).toLowerCase();\n        } else if (encoding.substr(0, 7) === 'printf ') {\n            var localeOptions = active.options;\n            value = applySpecifiers(value, encoding.substr(7), localeOptions.decimal, localeOptions.thousands);\n        }\n\n        return value;\n    };\n\n    /**\n     * Pad a value with characters on the left\n     * @param {String|Number} value the value to pad\n     * @param {Number} length minimum length for the output\n     * @param {String} ch the character to use for the padding\n     * @returns {*}\n     */\n    var padLeft = function (value, length, ch) {\n        value = value.toString();\n        while (value.length < length) {\n            value = ch + value;\n        }\n        return value;\n    };\n\n    /**\n     * Generate an array of all lowercase-uppercase combinations of a given string\n     * @param {String} text\n     * @returns {String[]}\n     */\n    var generateAllCasePermutations = (function () {\n\n        var recurse = function (results, lower, upper, hasCase, pre) {\n\n            var len = lower.length, currenLen = pre.length;\n\n            while (currenLen < len && !hasCase[currenLen]) {\n                pre += lower[currenLen++];\n            }\n\n            if (currenLen === len) {\n                return results.push(pre);\n            }\n\n            recurse(results, lower, upper, hasCase, pre + lower[currenLen]);\n            recurse(results, lower, upper, hasCase, pre + upper[currenLen]);\n        };\n\n        return function (text) {\n            text = text + '';\n            if (!text) return text;\n\n            var results = [];\n            var lower = text.split('');\n            var upper = [];\n            var hasCase = [];\n\n            for (var i = 0, len = text.length; i < len; i++) {\n                lower[i] = lower[i].toLowerCase();\n                upper[i] = lower[i].toUpperCase();\n                hasCase[i] = upper[i] !== lower[i];\n            }\n\n            recurse(results, lower, upper, hasCase, '');\n\n            return results;\n        };\n\n    })();\n\n    /**\n     * This will process value with printf specifier format\n     * @param {*} value the value to process\n     * @param {String?} specifiers the printf style specifiers. i.e. '2.5f', 'E', '#x'\n     * @param {String?} decimalSign the decimal separator character to use\n     * @param {String?} thousandsSign the thousands separator character to use\n     * @returns {String}\n     */\n    var applySpecifiers = function (value, specifiers, decimalSign, thousandsSign) {\n        if (!specifiers) return value;\n\n        var type = specifiers[specifiers.length - 1];\n        specifiers = specifiers.substr(0, specifiers.length - 1);\n\n        var isNumeric =\n            type === 'b' ||\n            type === 'c' ||\n            type === 'd' ||\n            type === 'i' ||\n            type === 'e' ||\n            type === 'E' ||\n            type === 'f' ||\n            type === 'g' ||\n            type === 'o' ||\n            type === 'u' ||\n            type === 'x' ||\n            type === 'X';\n        var isDecimalNumeric =\n            type === 'e' ||\n            type === 'E' ||\n            type === 'f' ||\n            type === 'g';\n        var isUpperCase =\n            type === 'E' ||\n            type === 'X';\n\n        if (isNumeric) {\n            if (typeof value !== 'number') {\n                value = parseInt(value, 10);\n            }\n            if (type === 'u') {\n                value = value >>> 0;\n            }\n\n            var parsedSpecifiers = specifiers.match(/(\\+)?( )?(#)?(0)?([0-9]+)?(,)?(.([0-9]+))?/);\n            var forceSign = parsedSpecifiers[1] === '+',\n                spaceSign = parsedSpecifiers[2] === ' ',\n                radiiOrDecimalSign = parsedSpecifiers[3] === '#',\n                padZero = parsedSpecifiers[4] === '0',\n                padCount = parsedSpecifiers[5] ? parseInt(parsedSpecifiers[5], 10) : 0,\n                hasThousands = parsedSpecifiers[6],\n                precision = parsedSpecifiers[8];\n\n            if (precision) {\n                precision = parseInt(precision, 10);\n            }\n\n            decimalSign = decimalSign || DEFAULT_DECIMAL_SEPARATOR;\n            thousandsSign = thousandsSign || DEFAULT_THOUSANDS_SEPARATOR;\n        }\n\n        if (type === 'b') {\n            value = value.toString(2);\n        } else if (type === 'c') {\n            value = String.fromCharCode(value);\n        } else if (type === 'd' || type === 'i' || type === 'u') {\n            value = value.toString();\n        } else if (type === 'e' || type === 'E') {\n            value = (precision !== undefined ? value.toExponential(parseInt(precision, 10)) : value.toExponential()).toString();\n        } else if (type === 'f') {\n            value = (precision !== undefined ? parseFloat(value).toFixed(parseInt(precision, 10)) : parseFloat(value)).toString();\n        } else if (type === 'g') {\n            value = parseFloat(value).toString();\n            if (precision !== undefined) {\n                var decimalIdx = value.indexOf('.');\n                if (decimalIdx > -1) {\n                    value = value.substr(0, decimalIdx + (precision > 0 ? 1 : 0) + precision);\n                }\n            }\n        } else if (type === 'o') {\n            value = value.toString(8);\n        } else if (type === 'x' || type === 'X') {\n            value = value.toString(16);\n        } else if (type === 's') {\n            value = value.toString();\n            if (precision !== undefined) {\n                value.substr(0, precision);\n            }\n        } else {\n            value = value.toString();\n        }\n\n        if (type === 'd' || type === 'i' || type === 'u' || type === 'x' || type === 'x' || type === 'X' || type === 'o') {\n            if (precision !== undefined) {\n                if (precision === 0 && value === '0') {\n                    value = '';\n                } else {\n                    value = padLeft(value, precision, '0');\n                }\n            }\n        }\n\n        if (value.length === 0) {\n            return value;\n        }\n\n        if (isDecimalNumeric) {\n            if (radiiOrDecimalSign && value.indexOf('.') === -1) {\n                value += '.';\n            }\n            value = value.replace(/\\./g, decimalSign);\n        }\n\n        if (isUpperCase) {\n            value = value.toUpperCase();\n        }\n\n        if (hasThousands) {\n            var decIndex = value.indexOf(decimalSign);\n            if (decIndex === -1) {\n                decIndex = value.length;\n            }\n            var signIndex = value.charAt(0) === '-' ? 1 : 0;\n            if (decIndex - signIndex > 3) {\n                var sepValue = '';\n                var major = value.substr(signIndex, decIndex - signIndex);\n                var fromIndex = 0, toIndex = major.length % 3;\n                while (fromIndex < major.length) {\n                    if (fromIndex > 0) {\n                        sepValue += thousandsSign;\n                    }\n                    sepValue += major.substring(fromIndex, toIndex);\n                    fromIndex = toIndex;\n                    toIndex = fromIndex + 3;\n                }\n                value = (signIndex ? '-' : '') + sepValue + value.substr(decIndex);\n            }\n        }\n\n        if (isNumeric) {\n            var sign = (value.charAt(0) === '-' ? '-' : (forceSign ? '+' : '')) || (spaceSign ? ' ' : '');\n\n            // Remove the - sign\n            if (sign === '-') {\n                value = value.substr(1);\n            }\n\n            var radiiSign = '';\n\n            // Prefix with the radii sign\n            if (radiiOrDecimalSign) {\n                if (type === 'x' || type === 'X') {\n                    radiiSign = '0x';\n                } else if (type === 'o') {\n                    radiiSign = '0';\n                }\n            }\n\n            // Zero padding - should be like \"0x00005\" for length of 7, where the radii sign is before padding\n            if (padCount && padZero) {\n                value = padLeft(value, padCount - sign.length - radiiSign.length, '0');\n            }\n\n            value = sign + radiiSign + value;\n\n            // Space padding - should be like \"    0x5\" for length of 7, where the radii sign is after padding\n            if (padCount && !padZero) {\n                value = padLeft(value, padCount, ' ');\n            }\n        }\n\n        return value;\n    };\n\n    /** @typedef i18n */\n    var i18n = {\n\n        /**\n         * Add a language to the localization object\n         * @public\n         * @param {String} langCode language code\n         * @param {Object} data localization object\n         * @param {ADD_LANGUAGE_OPTIONS?} options options for this language\n         * @returns {i18n} self\n         */\n        add: function (langCode, data, options) {\n            options = options || {};\n\n            var locOptions = {};\n            locOptions.plural = options.plural || defaultPlural;\n            locOptions.decimal = options.decimal || DEFAULT_DECIMAL_SEPARATOR;\n            locOptions.thousands = options.thousands || (locOptions.decimal === ',' ? '.' : ',');\n            locOptions.decimalOrThousandsRegex = new RegExp(\n                '(' + regexEscape(locOptions.decimal) +\n                ')|(' + regexEscape(locOptions.thousands) + ')', 'g');\n\n            locs[langCode] = {\n                code: langCode,\n                data: data,\n                options: locOptions\n            };\n\n            if (!activeLanguage) {\n                activeLanguage = langCode;\n                active = locs[langCode];\n            }\n\n            return this;\n        },\n\n        /**\n         * Get a language object from the localization\n         * @public\n         * @param {String} lang language code\n         * @param {Boolean?} tryFallbacks should we try to search in fallback scenarios i.e. 'en' for 'en-US'\n         * @returns {{ code: String, data: Object, options: Object }} language object\n         */\n        getLanguage: function (lang, tryFallbacks) {\n            if (tryFallbacks) {\n                if (lang === 'iw') lang = 'he'; // Fallback from Google's old spec, if the setting came from an old Android device\n                if (!lang) {\n                    lang = this.getAvailableLanguages()[0];\n                }\n                var found = null;\n                while (typeof lang === 'string') {\n                    if (found = locs[lang]) break;\n                    var idx = lang.lastIndexOf('-');\n                    if (idx < 0) {\n                        idx = lang.lastIndexOf('_');\n                    }\n                    if (idx > 0) {\n                        lang = lang.substr(0, idx);\n                    }\n                    else break;\n                }\n                if (!found) {\n                    lang = this.getAvailableLanguages()[0];\n                    found = locs[lang];\n                }\n                return found;\n            } else {\n                return locs[lang];\n            }\n        },\n\n        /**\n         * Retrieve a i18n value/object\n         * Accepted arguments are in the following formats:\n         *  (String keypath, [Boolean original], [Object options])\n         *  (String key, String key, String key, [Boolean original], [Object options])\n         *  (Array keypath, [Boolean original], [Object options])\n         *\n         * \"keypath\" is the path to the localized value.\n         * When the keypath is a String, each part is separated by a period.\n         * When the keypath is an Array, each part is a single part in the path.\n         *\n         * \"original\" specifies whether to access the original language, if the current language was extended. Default is false.\n         * \"options\" contains values that can be used in the localization,\n         *   and possibly the \"count\" property which is used for plural values,\n         *   or the \"gender\" property for selecting a gender from the target value.\n         *\n         * @public\n         * @param {...}\n         * @returns {*} localized value or object\n         */\n        t: function () {\n            var args = arguments,\n                argIndex = 0,\n                keys,\n                useOriginal = false,\n                locale,\n                tryFallback = true,\n                options,\n                i,\n                len;\n\n            // Normalize key(s)\n            if (typeof args[0] === 'string' && typeof args[1] !== 'string') {\n                keys = args[argIndex++];\n                if (keys.length === 0) {\n                    keys = [];\n                } else {\n                    keys = keys.split('.');\n                }\n            } else if (typeof args[0] === 'object' && 'length' in args[0]) {\n                keys = args[argIndex++];\n            } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {\n                var arg;\n                keys = [];\n                for (len = args.length; argIndex < len; argIndex++) {\n                    arg = args[argIndex];\n                    if (typeof arg === 'string') {\n                        keys.push(arg);\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            // `useOriginal` argument\n            options = args[argIndex++];\n            if (typeof options === 'boolean') {\n                useOriginal = options;\n                options = args[argIndex];\n            }\n\n            // Choose locale\n            if (useOriginal) {\n                locale = originalLocs[activeLanguage] || active;\n            } else {\n                locale = active;\n            }\n\n            var loc = locale.data;\n\n            // If no key is specified, return the root namespace\n            if (!keys.length) {\n                return loc;\n            }\n\n            // `while` because we might try multiple times,\n            // like first try with active locale, second time with fallback locale.\n            while (true) {\n\n                if (options && typeof options['count'] === 'number') { // Try for plural form\n\n                    // Loop on all of them except the last. We are going to test the last key combined with plural specifiers\n                    for (i = 0, len = keys.length - 1; i < len; i++) {\n                        loc = loc[keys[i]];\n\n                        // Avoid stepping into an undefined. Make systems more stable.\n                        // Anyone who queries for an invalid `t(...)` should handle the `undefined` himself.\n                        if (loc === undefined) {\n                            break;\n                        }\n                    }\n\n                    var pluralSpec = locale.options.plural;\n                    pluralSpec = pluralSpec(options['count']);\n\n                    var key = keys[keys.length - 1]; // This is the last key in the keys array\n\n                    if (pluralSpec && loc[key + '_' + pluralSpec]) {\n                        // We have a match for the plural form\n                        loc = loc[key + '_' + pluralSpec];\n                    } else {\n                        // Take the bare one\n                        loc = loc[key];\n                    }\n\n                } else {\n                    // No need for the plural form, as no 'count' was specified\n\n                    for (i = 0, len = keys.length; i < len; i++) {\n                        loc = loc[keys[i]];\n\n                        // Avoid stepping into an undefined. Make systems more stable.\n                        // Anyone who queries for an invalid `t(...)` should handle the `undefined` himself.\n                        if (loc === undefined) {\n                            break;\n                        }\n                    }\n                }\n\n                if (loc === undefined &&\n                    tryFallback &&\n                    fallbackLanguage &&\n                    fallbackLanguage !== activeLanguage) {\n\n                    tryFallback = false;\n\n                    if (locs.hasOwnProperty(fallbackLanguage)) {\n                        locale = locs[fallbackLanguage];\n                        loc = locale.data;\n                        continue;\n                    }\n                }\n\n                break;\n            }\n\n            if (options) {\n\n                if (typeof options['gender'] === 'string') { // Try for gender form\n\n                    if (typeof loc === 'object' &&\n                        !(loc instanceof Array)) {\n\n                        var gender = options['gender'], genderized;\n\n                        // Allow any gender, you can invent new ones...\n                        genderized = loc[gender];\n\n                        if (genderized === undefined) {\n\n                            // Fallback for male/female to m/f\n                            if (gender === 'male') {\n                                genderized = loc['m'];\n                            } else if (gender === 'female') {\n                                genderized = loc['f'];\n                            }\n\n                            // Fallbacks for neutral gender\n                            if (genderized === undefined) {\n                                genderized = loc['neutral'];\n                            }\n\n                            if (genderized === undefined) {\n                                genderized = loc['n'];\n                            }\n\n                            if (genderized === undefined) {\n                                genderized = loc[''];\n                            }\n\n                            // Default fallback\n\n                            if (genderized === undefined) {\n                                genderized = loc;\n                            }\n                        }\n\n                        loc = genderized;\n                    }\n\n                }\n            }\n\n            // Process special value contents based on whether there are `options` provided,\n            // or the value contains a special character\n            if (options ||\n                (typeof loc === 'string' && (loc.indexOf('{') > -1 || loc.indexOf('t(') > -1))) {\n                loc = i18n.processLocalizedString(loc, options);\n            }\n\n            return loc;\n        },\n\n        /**\n         * Get the decimal seperator for the active locale\n         * @public\n         * @returns {String} decimal separator\n         */\n        getDecimalSeparator: function () {\n            return active.options.decimal;\n        },\n\n        /**\n         * Get the thousands seperator for the active locale\n         * @public\n         * @returns {String} thousands separator\n         */\n        getThousandsSeparator: function () {\n            return active.options.thousands;\n        },\n\n        /**\n         * Set current active language using a language code.\n         * The function will fall back from full to two-letter ISO codes (en-US to en) and from bad Android like codes (en_US to en).\n         * @public\n         * @param {String} lang the language code to use\n         * @returns {i18n} self\n         */\n        setActiveLanguage: function (lang) {\n            var found = this.getLanguage(lang, true);\n            active = found;\n            activeLanguage = found.code;\n            return this;\n        },\n\n        /**\n         * Set the language code of the fallback language.\n         * By default there's no fallback language, so <code>undefined</code> could be returned when a key is not localized.\n         * The function will fall back from full to two-letter ISO codes (en-US to en) and from bad Android like codes (en_US to en).\n         * Note: For performance reasons, the fallback happens only if <code>setFallbackLanguage(...)</code> is called when all languages are already added. Otherwise, the specified language code is used as it is. \n         * @public\n         * @param {String} lang the language code to use\n         * @returns {i18n} self\n         */\n        setFallbackLanguage: function (lang) {\n            var found = this.getLanguage(lang, true);\n            fallbackLanguage = found ? found.code : lang;\n            return this;\n        },\n\n        /**\n         * Set current active language using a language code found in the document's lang attribute or a relevant meta tag.\n         * Calls setActiveLanguage to do the dirty work after detecting language code.\n         * @public\n         * @returns {i18n} self\n         */\n        setActiveLanguageFromMetaTag: function () {\n            var lang = document.documentElement.getAttribute('lang') || document.documentElement.getAttribute('xml:lang');\n            if (!lang) {\n                var metas = document.getElementsByTagName('meta');\n                for (var i = 0, meta; i < metas.length; i++) {\n                    meta = metas[i];\n                    if ((meta.getAttribute('http-equiv') || '').toLowerCase() == 'content-language') {\n                        lang = meta.getAttribute('content');\n                        break;\n                    }\n                }\n            }\n            return this.setActiveLanguage(lang);\n        },\n\n        /**\n         * Get the current active language code.\n         * @public\n         * @returns {String} current active language code\n         */\n        getActiveLanguage: function () {\n            return activeLanguage;\n        },\n\n        /**\n         * Get an array of the available language codes\n         * @public\n         * @returns {Array<String>} array of the available language codes\n         */\n        getAvailableLanguages: function () {\n            var langs = [];\n            for (var key in locs) {\n                if (!locs.hasOwnProperty(key)) continue;\n                langs.push(key);\n            }\n            return langs;\n        },\n\n        /**\n         * Extend a specific language with data from a localized object.\n         * In order to allow easy storage and retrieval of extensions from DBs, the extension data is built with\n         *   dotted syntax instead of a hieararchy of objects. i.e {\"parent.child\": \"value\"}\n         * @public\n         * @param {String} lang language code\n         * @param {Object} data localization object\n         * @returns {i18n} self\n         */\n        extendLanguage: function (lang, data) {\n            try {\n                if (locs[lang]) {\n                    if (!originalLocs[lang]) { // Back it up first\n                        originalLocs[lang] = JSON.parse(JSON.stringify(locs[lang]));\n                    }\n                    extendDotted(locs[lang].data, data);\n                }\n            } catch (e) { }\n            return this;\n        },\n\n        /**\n         * Extend the entire languages array, with the help of the extendLanguage function.\n         * @public\n         * @param {Object} data the localization extension object. each language as the key and extension object as the value.\n         * @returns {i18n} self\n         */\n        extendLanguages: function (data) {\n            try {\n                for (var lang in data) {\n                    if (!data.hasOwnProperty(lang)) continue;\n                    if (locs[lang]) {\n                        if (!originalLocs[lang]) { // Back it up first\n                            originalLocs[lang] = JSON.parse(JSON.stringify(locs[lang]));\n                        }\n                        extendDotted(locs[lang].data, data[lang]);\n                    }\n                }\n            } catch (e) { }\n            return this;\n        },\n\n        /**\n         * Retrieve a localized string of a physical file size, assuming that the \"size_abbrs\" key is available.\n         * @public\n         * @param {Number} bytes the number of bytes\n         * @returns {LOCALIZED_PHYSICAL_FILE_SIZE} localized size\n         */\n        physicalSize: function (bytes) {\n            var ret,\n                loc = i18n.t('size_abbrs');\n            if (bytes < 100) ret = { size: bytes, name: loc['b'] };\n            else if (bytes < 101376) ret = { size: bytes / 1024.0, name: loc['kb'] };\n            else if (bytes < 103809024) ret = { size: bytes / 1024.0 / 1024.0, name: loc['mb'] };\n            else if (bytes < 106300440576) ret = { size: bytes / 1024.0 / 1024.0 / 1024.0, name: loc['gb'] };\n            else ret = { size: bytes / 1024.0 / 1024.0 / 1024.0 / 1024.0, name: loc['tb'] };\n            ret.size = (Math.ceil(ret.size * 100) / 100); // Max two decimal points\n            return ret;\n        },\n\n        /**\n         * Format a date to a localized string, assuming that the \"calendar\" key is available.\n         * Supports all formatting codes known to humanity.\n         * @public\n         * @param {Date} date The date to format\n         * @param {String} format The format\n         * @param {String|Object|null|?} culture Can accept a culture code, a culture object,\n         *                                       or a simple \"calendar\" object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\n         * @returns {String} A localized date\n         */\n        formatDate: (function () {\n\n            var formatMatcher = /d{1,4}|M{1,4}|yy(?:yy)?|([HhmsTt])\\1?|[LloSZ]|UTC|('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|(\\[[^\\]\\\\]*(?:\\\\.[^\\]\\\\]*)*])/g,\n                timezone = /\\b(?:[PMCEA][SDP]T|[a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)?(?:[-+]\\d{4})?)\\b/g,\n                timezoneClip = /[^-+\\dA-Z]/g;\n\n            /** @typedef {{d: function, D: function, M: function, y: function, H: function, m: function, s: function, L: function, o: function, utcd: function, utc: function}} FlagMap */\n\n            /** @type {FlagMap} */\n            var flagSubMapLocal = {\n                /** @param {Date} d */ /** @returns {Number} */ 'd': function (d) { return d.getDate(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'D': function (d) { return d.getDay(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'M': function (d) { return d.getMonth(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'y': function (d) { return d.getFullYear(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'H': function (d) { return d.getHours(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'm': function (d) { return d.getMinutes(); },\n                /** @param {Date} d */ /** @returns {Number} */ 's': function (d) { return d.getSeconds(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'L': function (d) { return d.getMilliseconds(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'o': function (d) { return 0; },\n                /** @param {Date} d */ /** @returns {String} */ 'utcd': function (d) { return ((d + '').match(timezone) || ['']).pop().replace(timezoneClip, ''); },\n                /** @param {Date} d */ /** @returns {String} */ 'utc': function (d) { var z = d.getTimezoneOffset(), s = (z > 0 ? '-' : '+'); z = z < 0 ? -z : z; var zm = z % 60; return s + padLeft((z - zm) / 60, 2, '0') + (zm ? padLeft(zm, 2, '0') : ''); }\n            };\n\n            /** @type {FlagMap} */\n            var flagSubMapUtc = {\n                /** @param {Date} d */ /** @returns {Number} */ 'd': function (d) { return d.getUTCDate(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'D': function (d) { return d.getUTCDay(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'M': function (d) { return d.getUTCMonth(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'y': function (d) { return d.getUTCFullYear(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'H': function (d) { return d.getUTCHours(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'm': function (d) { return d.getUTCMinutes(); },\n                /** @param {Date} d */ /** @returns {Number} */ 's': function (d) { return d.getUTCSeconds(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'L': function (d) { return d.getUTCMilliseconds(); },\n                /** @param {Date} d */ /** @returns {Number} */ 'o': function (d) { return d.getTimezoneOffset(); },\n                /** @param {Date} d */ /** @returns {String} */ 'utcd': function (d) { return \"UTC\" },\n                /** @param {Date} d */ /** @returns {String} */ 'utc': function (d) { return \"Z\" }\n            };\n\n            var flagMap = {\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'd': function (o, fmap) { return fmap.d(o); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'dd': function (o, fmap) { return padLeft(fmap.d(o), 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'ddd': function (o, fmap, culture) { return culture['weekdays_short'][fmap.D(o)]; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'dddd': function (o, fmap, culture) { return culture['weekdays'][fmap.D(o)]; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'M': function (o, fmap) { return fmap.M(o) + 1; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'MM': function (o, fmap) { return padLeft(fmap.M(o) + 1, 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'MMM': function (o, fmap, culture) { return culture['months_short'][fmap.M(o)]; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'MMMM': function (o, fmap, culture) { return culture['months'][fmap.M(o)]; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'yy': function (o, fmap) { return String(fmap.y(o)).slice(2); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'yyyy': function (o, fmap) { return fmap.y(o); },\n\n                /** @param {FlagMap} fmap */ /** @return {Number} */\n                'h': function (o, fmap) { return fmap.H(o) % 12 || 12; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'hh': function (o, fmap) { return padLeft(fmap.H(o) % 12 || 12, 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'H': function (o, fmap) { return fmap.H(o); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'HH': function (o, fmap) { return padLeft(fmap.H(o), 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'm': function (o, fmap) { return fmap.m(o); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'mm': function (o, fmap) { return padLeft(fmap.m(o), 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                's': function (o, fmap) { return fmap.s(o); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'ss': function (o, fmap) { return padLeft(fmap.s(o), 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'l': function (o, fmap) { return padLeft(fmap.L(o), 3, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'L': function (o, fmap) { var L = fmap.L(o); return padLeft(L > 99 ? Math.round(L / 10) : L, 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'f': function (o, fmap) { return Math.floor(fmap.L(o) / 100).toString(); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'ff': function (o, fmap) { return padLeft(Math.floor(fmap.L(o) / 10), 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'fff': function (o, fmap) { return padLeft(fmap.L(o), 3, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'ffff': function (o, fmap) { return padLeft(fmap.L(o), 3, '0') + '0'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'fffff': function (o, fmap) { return padLeft(fmap.L(o), 3, '0') + '00'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'ffffff': function (o, fmap) { return padLeft(fmap.L(o), 3, '0') + '000'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'fffffff': function (o, fmap) { return padLeft(fmap.L(o), 3, '0') + '0000'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'F': function (o, fmap) { var v = Math.floor(fmap.L(o) / 100); if (v === 0) return ''; return v.toString(); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FF': function (o, fmap) { var v = Math.floor(fmap.L(o) / 10); if (v === 0) return ''; return padLeft(v, 2, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FFF': function (o, fmap) { var v = fmap.L(o); if (v === 0) return ''; return padLeft(v, 3, '0'); },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FFFF': function (o, fmap) { var v = fmap.L(o); if (v === 0) return ''; return padLeft(v, 3, '0') + '0'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FFFFF': function (o, fmap) { var v = fmap.L(o); if (v === 0) return ''; return padLeft(v, 3, '0') + '00'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FFFFFF': function (o, fmap) { var v = fmap.L(o); if (v === 0) return ''; return padLeft(v, 3, '0') + '000'; },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'FFFFFFF': function (o, fmap) { var v = fmap.L(o); if (v === 0) return ''; return padLeft(v, 3, '0') + '0000'; },\n\n                't': function (o, fmap, culture) {\n                    return fmap.H(o) < 12 ?\n                        culture['am_short_lower'] || 'a' :\n                        culture['pm_short_lower'] || 'p'\n                },\n\n                'tt': function (o, fmap, culture) {\n                    return fmap.H(o) < 12 ?\n                        culture['am_lower'] || 'am' :\n                        culture['am_lower'] || 'pm'\n                },\n\n                'T': function (o, fmap, culture) {\n                    return fmap.H(o) < 12 ?\n                        culture['am_short_upper'] || 'A' :\n                        culture['pm_short_upper'] || 'P'\n                },\n\n                'TT': function (o, fmap, culture) {\n                    return fmap.H(o) < 12 ?\n                        culture['am_upper'] || 'AM' :\n                        culture['pm_upper'] || 'PM'\n                },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'Z': function (o, fmap) { return fmap.utc(o) },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'UTC': function (o, fmap) { return fmap.utcd(o) },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'o': function (o, fmap) { o = fmap.o(o); return (o > 0 ? \"-\" : \"+\") + padLeft(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4, '0') },\n\n                /** @param {FlagMap} fmap */ /** @return {string} */\n                'S': function (o, fmap) { var d = fmap.d(o); return [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10] }\n            };\n\n            return function (date, format, culture) {\n\n                if (culture && typeof culture === 'string') {\n                    culture = i18n.getLanguage(culture, true);\n\n                    if (culture) {\n                        culture = culture['calendar'];\n                    }\n                }\n\n                culture = culture || i18n.t('calendar') || {};\n\n                // Passing date through Date applies Date.parse, if necessary\n                if (date == null) {\n                    date = new Date();\n                } else if (typeof date === 'string') {\n                    date = i18n.parseDate(date, null, culture);\n                } else if (date instanceof Date) {\n                    // date = new Date(date);\n                } else if (typeof date === 'number') {\n                    date = new Date(date);\n                } else {\n                    date = NaN;\n                }\n\n                if (isNaN(date)) throw new SyntaxError(\"invalid date\");\n\n                var utc = false;\n\n                if (!format) {\n                    format = 'yyyy-MM-dd'; // ISO\n                }\n\n                // Allow setting the utc argument via the a special UTC: specifier\n                if (format.substr(0, 4) === 'UTC:') {\n                    utc = true;\n                    format = format.slice(4);\n                }\n\n                // Allow setting the utc argument via the Z specifier\n                if (format.charAt(format.length - 1) === 'Z') {\n                    utc = true;\n                }\n\n                var f = utc ? flagSubMapUtc : flagSubMapLocal;\n\n                return format.replace(formatMatcher, function (token) {\n                    return (token in flagMap) ? (flagMap[token])(date, f, culture) : token.slice(1, token.length - 1);\n                });\n            };\n        })(),\n\n        /**\n         * Parses a date from user input, based on a supplied format. This is the counterpart of the formatDate function.\n         * Supports all formatting codes known to humanity.\n         * Will automatically fall back if missing a digit i.e 1/2/34 for dd/MM/yyyy, unless `strict` is specified.\n         * Forgiving behavior with \"incorrect\" separators, i.e 01.05 instead of 01/05, unless `strict` is specified.\n         * If year is missing, it will default to current year. Anything else will default to zero.\n         *\n         * This function actually uses the `createDateParser(...)` function, and caches the result.\n         * @public\n         * @expose\n         * @param {String} date The date to parse\n         * @param {String?} format The format. Defaults to UTC ISO. (yyyy-MM-DD'T'HH:mm:ssZ)\n         * @param {String|Object|null|?} culture Can accept a culture code, a culture object,\n         *                                       or a simple \"calendar\" object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\n         * @param {Boolean?} strict Should the parser be strict? false by default, forgiving missing digits etc.\n         * @returns {Date} The parsed date\n         */\n        parseDate: function (date, format, culture, strict) {\n\n            if (culture && typeof culture === 'string') {\n                culture = i18n.getLanguage(culture, true);\n\n                if (culture) {\n                    culture = culture['calendar'];\n                }\n            }\n\n            culture = culture || i18n.t('calendar') || {};\n\n            if (!format) {\n                if ('parse' in Date) {\n                    return new Date(date);\n                } else {\n                    var parsed = this.parseDate(date, 'yyyy-MM-dd\\'T\\'HH:mm:ss[.FFFFFFF]Z', culture, true);\n                    if (isNaN(+parsed)) parsed = this.parseDate(date, 'yyyy-MM-dd', culture, true);\n                    if (isNaN(+parsed)) parsed = this.parseDate(date, 'ddd, dd, MMM yyyy HH:mm:ss Z', culture, true);\n                    if (isNaN(+parsed)) parsed = this.parseDate(date, 'dddd, dd-MMM-yy HH:mm:ss Z', culture, true);\n                    if (isNaN(+parsed)) parsed = this.parseDate(date, 'ddd MMM d HH:mm:ss yyyy', culture, true);\n                    return parsed;\n                }\n            }\n\n            var compiled = culture[strict ? '_compiledParsersE' : '_compiledParsers'];\n            if (!compiled) {\n                culture[strict ? '_compiledParsersE' : '_compiledParsers'] = compiled = {};\n            }\n\n            if (!compiled[format]) {\n                compiled[format] = i18n.createDateParser(format, culture, strict);\n            }\n\n            return compiled[format](date, culture);\n        },\n\n        /**\n         * Creates a date parser. This is generally used (and cached) by `parseDate(...)`.\n         * Supports all formatting codes known to humanity.\n         * Will automatically fall back if missing a digit i.e 1/2/34 for dd/MM/yyyy, unless `strict` is specified.\n         * Forgiving behavior with \"incorrect\" separators, i.e 01.05 instead of 01/05, unless `strict` is specified.\n         * If year is missing, it will default to current year. Anything else will default to zero.\n         * @public\n         * @expose\n         * @param {String} format The format\n         * @param {Object} culture An object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\n         * @param {Boolean} strict Should the parser be strict? false by default, forgiving missing digits etc.\n         * @returns {function(String):Date} The parser function\n         */\n        createDateParser: (function () {\n            var partsRgx = /('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|(\\[[^\\]\\\\]*(?:\\\\.[^\\]\\\\]*)*])|yyyy|yy|MMMM|MMM|MM|M|dddd|ddd|dd|d|HH|H|hh|h|mm|m|ss|s|l|L|f|ff|fff|ffff|fffff|ffffff|fffffff|F|FF|FFF|FFFF|FFFFF|FFFFFF|FFFFFFF|tt|t|TT|T|Z|UTC|o|S|.+?/g;\n\n            var arrayToRegex = function (array) {\n                var regex = '';\n                for (var i = 0; i < array.length; i++) {\n                    if (i > 0) regex += '|';\n                    regex += regexEscape(array[i]);\n                }\n                return regex;\n            };\n\n            var regexMap = {\n                'yyyy': function (c, s) { return s ? '[0-9]{4}' : '[0-9]{2}|[0-9]{4}'; },\n                'yy': function (c, s) { return '[0-9]{2}'; },\n                'MMMM': function (c, s) { return arrayToRegex(c['months']); },\n                'MMM': function (c, s) { return arrayToRegex(c['months_short']); },\n                'MM': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                'M': function (c, s) { return '[0-9]{1,2}'; },\n                'dddd': function (c, s) { return arrayToRegex(c['days']); },\n                'ddd': function (c, s) { return arrayToRegex(c['days_short']); },\n                'dd': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                'd': function (c, s) { return '[0-9]{1,2}'; },\n                'HH': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                'H': function (c, s) { return '[0-9]{1,2}'; },\n                'hh': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                'h': function (c, s) { return '[0-9]{1,2}'; },\n                'mm': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                'm': function (c, s) { return '[0-9]{1,2}'; },\n                'ss': function (c, s) { return s ? '[0-9]{2}' : '[0-9]{1,2}'; },\n                's': function (c, s) { return '[0-9]{1,2}'; },\n                'l': function (c, s) { return '[0-9]{3}'; },\n                'L': function (c, s) { return '[0-9]{2}'; },\n                'f': function (c, s) { return '[0-9]{1}'; },\n                'ff': function (c, s) { return '[0-9]{2}'; },\n                'fff': function (c, s) { return '[0-9]{3}'; },\n                'ffff': function (c, s) { return '[0-9]{4}'; },\n                'fffff': function (c, s) { return '[0-9]{5}'; },\n                'ffffff': function (c, s) { return '[0-9]{6}'; },\n                'fffffff': function (c, s) { return '[0-9]{7}'; },\n                'F': function (c, s) { return '[0-9]{0,1}'; },\n                'FF': function (c, s) { return '[0-9]{0,2}'; },\n                'FFF': function (c, s) { return '[0-9]{0,3}'; },\n                'FFFF': function (c, s) { return '[0-9]{0,4}'; },\n                'FFFFF': function (c, s) { return '[0-9]{0,5}'; },\n                'FFFFFF': function (c, s) { return '[0-9]{0,6}'; },\n                'FFFFFFF': function (c, s) { return '[0-9]{0,7}'; },\n                'tt': function (c, s) {\n                    var am1 = c['am_lower'] || 'am';\n                    var pm1 = c['pm_lower'] || 'pm';\n                    var am2 = c['am_upper'] || 'AM';\n                    var pm2 = c['pm_upper'] || 'PM';\n\n                    var all = generateAllCasePermutations(am1)\n                        .concat(generateAllCasePermutations(pm1));\n\n                    if (am1.toLowerCase() !== am2.toLowerCase()) {\n                        all = all.concat(generateAllCasePermutations(am2));\n                    }\n\n                    if (pm1.toLowerCase() !== pm2.toLowerCase()) {\n                        all = all.concat(generateAllCasePermutations(pm2));\n                    }\n\n                    return arrayToRegex(all);\n                },\n                't': function (c, s) {\n                    var am1 = c['am_short_lower'] || 'a';\n                    var pm1 = c['pm_short_lower'] || 'p';\n                    var am2 = c['am_short_upper'] || 'A';\n                    var pm2 = c['pm_short_upper'] || 'P';\n\n                    var all = generateAllCasePermutations(am1)\n                        .concat(generateAllCasePermutations(pm1));\n\n                    if (am1.toLowerCase() !== am2.toLowerCase()) {\n                        all = all.concat(generateAllCasePermutations(am2));\n                    }\n\n                    if (pm1.toLowerCase() !== pm2.toLowerCase()) {\n                        all = all.concat(generateAllCasePermutations(pm2));\n                    }\n\n                    return arrayToRegex(all);\n                },\n                'TT': function (c, s) { return regexMap['tt'](c, s); },\n                'T': function (c, s) { return regexMap['t'](c, s); },\n                'Z': function (c, s) { return 'Z|(?:GMT|UTC)?[+-][0-9]{2,4}(?:\\\\([a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time\\\\))?'; },\n                'UTC': function (c, s) { return '[+-][0-9]{2,4}'; },\n                'o': function (c, s) { return '[+-][0-9]{4}'; },\n                'S': function (c, s) { return 'th|st|nd|rd'; }\n            };\n\n            return function (format, culture, strict) {\n\n                var regex = '';\n                var regexParts = [];\n\n                var processFormat = function (format) {\n                    var formatParts = format.match(partsRgx);\n\n                    var i, count, part, shouldStrict;\n\n                    // Remove all empty groups\n                    for (i = 0, count = formatParts.length; i < count; i++) {\n                        if (formatParts[i].length === 0 || formatParts[i] === '[]') {\n                            formatParts.splice(i, 1);\n                            i--;\n                            count--;\n                        }\n                    }\n\n                    // Go over all parts in the format, and create the parser regex part by part\n                    for (i = 0, count = formatParts.length; i < count; i++) {\n                        part = formatParts[i];\n                        if (part[0] === '[' && part[part.length - 1] === ']') {\n                            regex += '(?:';\n                            processFormat(part.substr(1, part.length - 2));\n                            regex += ')?';\n                        } else if (regexMap.hasOwnProperty(part)) {\n                            // An actually recognized part\n                            shouldStrict = strict || // We are specifically instructed to use strict mode\n                                (i > 0 && regexMap.hasOwnProperty(formatParts[i - 1])) || // Previous part is not some kind of a boundary\n                                (i < count - 1 && regexMap.hasOwnProperty(formatParts[i + 1])); // Next part is not some kind of a boundary\n\n                            regex += '(' + regexMap[part](culture, shouldStrict) + ')';\n                            regexParts.push(part);\n                        } else {\n                            // A free text node\n\n                            // Remove enclosing quotes if there are...\n                            if (part[0] === \"'\") {\n                                part = part.replace(/'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'/, '$1');\n                            } else if (part[0] === '\"') {\n                                part = part.replace(/\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"/, '$1');\n                            }\n\n                            part = part.replace(/\\\\\\\\/g, '\\\\'); // Unescape\n                            if (!strict && (part === '/' || part === '.' || part === '-')) {\n                                regex += '([/\\\\.-])';\n                            } else {\n                                regex += '(' + regexEscape(part) + ')';\n                            }\n                            regexParts.push('');\n                        }\n                    }\n                };\n\n                processFormat(format);\n\n                regex = new RegExp('^' + regex + '$');\n\n                // This is for calculating which side to go for 2 digit years\n                var baseYear = Math.floor((new Date()).getFullYear() / 100) * 100;\n\n                // Return a parser function\n                return function (date) {\n                    date = date + '';\n                    var parts = date.match(regex);\n                    if (!parts) return null;\n\n                    parts.splice(0, 1); // Remove main capture group 0\n\n                    var now = new Date(),\n                        nowYear = now.getFullYear();\n                    var year = null, month = null, day = null,\n                        hours = null, hours12 = false, hoursTT, minutes = null,\n                        seconds = null, milliseconds = null,\n                        timezone = null;\n\n                    for (var i = 0, len = parts.length, part, tmp; i < len; i++) {\n                        part = parts[i];\n                        switch (regexParts[i]) {\n                            case 'yyyy':\n                            case 'yy':\n                                year = parseInt(part, 10);\n                                if (year < 100) {\n                                    year += baseYear;\n                                    if (year - nowYear > 50) {\n                                        year -= 100;\n                                    } else if (nowYear - year > 50) {\n                                        year += 100;\n                                    }\n                                }\n                                break;\n\n                            case 'MMMM':\n                                tmp = arrayIndexOf(culture['months'], part);\n                                if (tmp > -1) month = tmp;\n                                break;\n\n                            case 'MMM':\n                                tmp = arrayIndexOf(culture['months_short'], part);\n                                if (tmp > -1) month = tmp;\n                                break;\n\n                            case 'MM':\n                            case 'M':\n                                month = parseInt(part, 10) - 1;\n                                break;\n\n                            case 'dddd':\n                                tmp = arrayIndexOf(culture['days'], part);\n                                if (tmp > -1) day = tmp;\n                                break;\n\n                            case 'ddd':\n                                tmp = arrayIndexOf(culture['days_short'], part);\n                                if (tmp > -1) day = tmp;\n                                break;\n\n                            case 'dd':\n                            case 'd':\n                                day = parseInt(part, 10);\n                                break;\n\n                            case 'HH':\n                            case 'H':\n                                hours = parseInt(part, 10);\n                                hours12 = false;\n                                break;\n\n                            case 'hh':\n                            case 'h':\n                                hours = parseInt(part, 10);\n                                hours12 = true;\n                                break;\n\n                            case 'mm':\n                            case 'm':\n                                minutes = parseInt(part, 10);\n                                break;\n\n                            case 'ss':\n                            case 's':\n                                seconds = parseInt(part, 10);\n                                break;\n\n                            case 'l':\n                                milliseconds = parseInt(part, 10);\n                                break;\n\n                            case 'L':\n                                milliseconds = parseInt(part, 10);\n                                if (milliseconds < 10) {\n                                    milliseconds *= 100;\n                                } else {\n                                    milliseconds *= 10;\n                                }\n                                break;\n\n                            case 'f': case 'ff': case 'fff': case 'ffff':\n                            case 'fffff': case 'ffffff': case 'fffffff':\n                            case 'F': case 'FF': case 'FFF': case 'FFFF':\n                            case 'FFFFF': case 'FFFFFF': case 'FFFFFFF':\n                            if (part.length > 3) {\n                                part = part.substr(0, 3) + '.' + part.substr(3);\n                            } else if (part.length < 3) {\n                                while (part.length < 3) {\n                                    part += '0';\n                                }\n                            }\n                            milliseconds = parseFloat(part);\n                            break;\n\n                            case 'tt':\n                            case 't':\n                            case 'TT':\n                            case 'T':\n                                if (hours12) {\n                                    hoursTT = part.toLowerCase();\n                                }\n                                break;\n\n                            case 'Z':\n                            case 'UTC':\n                            case 'o':\n                                var tz = part.match(/(Z)|(?:GMT|UTC)?([+-][0-9]{2,4})(?:\\([a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time\\))?/);\n                                if (tz[1] === 'Z') {\n                                    timezone = 0;\n                                } else if (tz[2]) {\n                                    timezone = (parseInt(tz[2].substr(1, 2), 10) || 0) * 60 + (parseInt(tz[2].substr(3), 10) || 0);\n                                    if (tz[2].charAt(0) === '-') {\n                                        timezone = -timezone;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n\n                    if (year === null) year = now.getFullYear();\n                    if (month === null) month = now.getMonth();\n                    if (day === null) day = 1;\n                    if (hours12) {\n                        if (hoursTT === (culture['am_lower'] || 'am').toLowerCase() ||\n                            hoursTT === (culture['am_short_lower'] || 'a').toLowerCase()) {\n                            if (hours === 12) hours = 0;\n                        } else if (hoursTT === (culture['pm_lower'] || 'pm').toLowerCase() ||\n                            hoursTT === (culture['pm_short_lower'] || 'p').toLowerCase()) {\n                            if (hours < 12) hours += 12;\n                        }\n                    }\n                    var parsedDate = new Date(year, month, day, hours || 0, minutes || 0, seconds || 0, milliseconds || 0);\n                    if (timezone !== null) {\n                        timezone += parsedDate.getTimezoneOffset();\n                    }\n                    parsedDate.setMinutes(parsedDate.getMinutes() - timezone);\n\n                    return parsedDate;\n                };\n            };\n\n        })(),\n\n        /**\n         * Try to detect, based on the browser's localization, which is the short date format appropriate.\n         * So allegedly, a US user will have MM/dd/yyyy and GB will have d/MM/yyyy.\n         * Currently browsers do not seem to behave and use the correct formats of the OS!\n         * @public\n         * @expose\n         * @param {String} fallback a fallback date for a case where the browser does not support this functionality.\n         * @returns {String} the detected format, the fallback, or dd/MM/yyyy as default.\n         */\n        detectShortDateFormat: function (fallback) {\n            if (!Date.prototype.toLocaleDateString) return fallback || 'dd/MM/yyyy';\n\n            return new Date(2013, 1, 1).toLocaleDateString()\n                .replace(/\\b2013\\b/, 'yyyy').replace(/\\b13\\b/, 'yy')\n                .replace(/\\b02\\b/, 'MM').replace(/\\b2\\b/, 'M')\n                .replace(/\\b01\\b/, 'dd').replace(/\\b1\\b/, 'd');\n        },\n\n        /**\n         * Format a number for display using the correct decimal separator detected from the browser.\n         * @public\n         * @expose\n         * @param {Number|String|null} value the value to format.\n         * @param {Boolean=} thousands should we add a thousands separator\n         * @returns {String} The formatted number as string.\n         *                   If null or empty string is supplied, then an empty string is returned.\n         *                   If a string was supplied, it is returned as-is.\n         */\n        displayNumber: function (value, thousands) {\n            if (value === '' || value == null) return '';\n            if (typeof value === 'number') {\n                value = value.toString();\n\n                var decimalSep = active.options.decimal,\n                    thousandsSep = active.options.thousands;\n\n                if (decimalSep !== '.') {\n                    value = value.replace(/\\./g, decimalSep);\n                }\n                if (thousands) {\n                    var decIndex = value.indexOf(decimalSep);\n                    if (decIndex === -1) {\n                        decIndex = value.length;\n                    }\n                    var sign = value.charAt(0) === '-' ? 1 : 0;\n                    if (decIndex - sign > 3) {\n                        var sepValue = '';\n                        var major = value.substr(sign, decIndex - sign);\n                        var fromIndex = 0, toIndex = major.length % 3;\n                        while (fromIndex < major.length) {\n                            if (fromIndex > 0) {\n                                sepValue += thousandsSep;\n                            }\n                            sepValue += major.substring(fromIndex, toIndex);\n                            fromIndex = toIndex;\n                            toIndex = fromIndex + 3;\n                        }\n                        value = (sign ? '-' : '') + sepValue + value.substr(decIndex);\n                    }\n                }\n                return value;\n            }\n            return value.toLocaleString();\n        },\n\n        /**\n         * Parses a number from user input using the correct decimal separator detected from the browser.\n         *\n         * By default it will behave like `parseFloat`, where thousands separators are not supported.\n         * If `thousands` is `true`, then it will allow parsing with the separator.\n         * @public\n         * @expose\n         * @param {Number|String|null} value the value to parse.\n         * @param {Boolean?} [thousands=false] - Don't break when there are thousands separators in the value\n         * @returns {Number|null} The parsed number.\n         *                   If null or empty string is supplied, then null is returned.\n         *                   If a number was supplied, it is returned as-is.\n         */\n        parseNumber: function (value, thousands) {\n            if (value === '' || value == null) return null;\n\n            if (typeof value !== 'number') {\n                return parseFloat(\n                    value.replace(active.options.decimalOrThousandsRegex, function (g0, dec, tho) {\n                        if (dec) return '.';\n                        if (tho) return thousands ? '' : ',';\n                        return g0;\n                    })\n                );\n            }\n\n            return value;\n        },\n\n        /**\n         * Process a localized string.\n         *\n         * Pass 1:\n         *      Look for localization value specified in the form of:\n         *          {key.subkey}\n         *          {key.subkey|filter|filter...}\n         *\n         *      Possible filters are:\n         *          html\n         *          htmll - multiline HTML. replaces \\n with <br />\n         *          json\n         *          url\n         *          lower\n         *          upper\n         *          upperfirst\n         *          printf [print-specifier]\n         *\n         *      * `printf-specifier`s are C-style format specifiers. i.e. 2.5f\n         *      * The i18n keys will receive the `data` passed to `processLocalizedString`\n         *\n         *      And for placeholders from the passed options, in the form of:\n         *          {{count}}\n         *          {{data.value|filter|filter...}}\n         *\n         *          etc.\n         *\n         * Pass 2:\n         *      Look for i18n calls in the form of:\n         *          t(\"key.path\") t('key.path') t(key.path) or t(\"key.path\", {\"count\": 5})\n         *      Where the options part must be a valid JSON\n         *      This stage is affected by previous stages (i.e placeholders can be JSON encoded for t(...) calls\n         *\n         * localization format is {key.path[|filter][|filter]}\n         * Placeholder format is {{key.path[|filter][|filter]}}\n         *\n         * Printf specifiers are in this order:\n         *\n         *  \"[+][ ][#][0][width][,][.precision]\" and then one of [bcdieEfgouxXs]\n         *\n         * +            : Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers.\n         * (space)      : If no sign is going to be written, a blank space is inserted before the value.\n         * #            : For o, x or X specifiers the value is prefixed with 0, 0x or 0X respectively for values different than zero.\n         *                For with e, E, f, g it forces the written output to contain a decimal point even if no more digits follow\n         * 0            : Left-pads the number with zeroes (0) instead of spaces when padding is specified\n         * (width)      : Minimum number of characters to be printed, left-padded with spaces or zeroes.\n         *                If shorter than the number, then the number is not truncated.\n         * ,            : For d, i, u, f, g specifiers, adds thousand grouping characters\n         * (precision)  : For integer specifiers (d, i, u, o, x, X) - specifies the minimum number of digits to be written. Does not truncate, except for 0.\n         *                For e, E, f specifiers: this is the number of digits to be printed after the decimal point\n         *                For g specifier: This is the maximum number of significant digits to be printed.\n         *                For s: this is the maximum number of characters to be printed\n         *\n         * @param {String} value - the value to process\n         * @param {Object?} data - the data for post processing. Passed to {...} specifiers too.\n         * @returns {string} the processed value\n         */\n        processLocalizedString: function (value, data) {\n\n            if (typeof value !== 'string') return value;\n\n            value = value.replace(/(\\\\*)(\\{{1,2})([^|{}\"]+)((?:\\|[^|{}]+)*?)(}{1,2})/g, function () {\n\n                var precedingBackslahes = arguments[1];\n                var openingBrackets = arguments[2];\n                var closingBrackets = arguments[5];\n\n                if ((precedingBackslahes.length & 1) === 1) {\n                    return arguments[0].substr(precedingBackslahes.length - (precedingBackslahes.length - 1) / 2);\n                }\n\n                if (openingBrackets.length > closingBrackets.length) {\n                    return arguments[0];\n                }\n\n                var value, key = arguments[3];\n                var i, len;\n\n                if (openingBrackets.length === 1) {\n\n                    value = i18n.t(key, data);\n\n                } else {\n\n                    var keys = key.split('.');\n                    value = data;\n                    for (i = 0, len = keys.length; i < len && value; i++) {\n                        value = value[keys[i]];\n                    }\n                    if (value == null) {\n                        value = '';\n                    }\n\n                }\n\n                if (arguments[4]) {\n                    var filters = arguments[4].split('|');\n                    for (i = 0, len = filters.length; i < len; i++) {\n                        if (!filters[i]) continue;\n                        value = encodeValue(value, filters[i]);\n                    }\n                }\n\n                if (closingBrackets.length > openingBrackets.length) {\n                    value = value + closingBrackets.substr(openingBrackets.length);\n                }\n\n                return (precedingBackslahes.length ?\n                        precedingBackslahes.substr(precedingBackslahes.length / 2) :\n                        '') + value;\n            });\n\n            value = value.replace(/t\\((\"[^\"]+?\"|'[^']+?'|[^,)]+?)(?:,\\s*(\\{.*?}))?\\)/g, function () {\n\n                var key = arguments[1],\n                    options = arguments[2];\n                try {\n                    key = JSON.parse(key);\n                }\n                catch (e) {\n                    return arguments[0];\n                }\n                if (options) {\n                    try {\n                        options = JSON.parse(options);\n                    }\n                    catch (e) {\n                        options = null;\n                    }\n                }\n\n                return i18n.t(key, options);\n\n            });\n\n            return value;\n\n        }\n\n    };\n\n    // Helper function to extend an object using a synthetic object structure from dotted syntax to a real nested structure.\n    function extendDotted(target, data) {\n        if (data == null) return;\n        var dotted, targetDotted, i;\n        for (var key in data) {\n            if (!data.hasOwnProperty(key) || !data[key]) continue;\n            dotted = key.split('.');\n            targetDotted = target;\n            for (i = 0; i < dotted.length - 1; i++) {\n                targetDotted = targetDotted[dotted[i]];\n            }\n            targetDotted[dotted[dotted.length - 1]] = data[key];\n        }\n    }\n\n    /**\n     * @typedef LOCALIZED_PHYSICAL_FILE_SIZE\n     * */\n    var LOCALIZED_PHYSICAL_FILE_SIZE = {\n        /**\n         * @expose\n         * @type {Number}\n         * */\n        size: 0,\n\n        /**\n         * @expose\n         * @type {String}\n         * */\n        name: ''\n    };\n\n    /**\n     * This function returns a key suffix for plural form, for the specified count.\n     * @function PLURAL_FORM_FUNCTION\n     * @param {Number} count the number that we need to inspect\n     * @returns {string}\n     */\n\n    /**\n     * @typedef ADD_LANGUAGE_OPTIONS\n     * */\n    var ADD_LANGUAGE_OPTIONS = {\n        /**\n         * function that takes a number, and returns a key suffix for plural form of that count.\n         * @expose\n         * @type {PLURAL_FORM_FUNCTION}\n         * */\n        plural: null,\n\n        /**\n         * decimal separator character. The default is auto-detected from the browser locale\n         * @expose\n         * @type {String}\n         * */\n        decimal: '.',\n\n        /**\n         * thousands separator character. The default is auto-detected from the browser locale\n         * @expose\n         * @type {String}\n         * */\n        thousands: ','\n    };\n\n    return i18n;\n});\n\n//# sourceURL=webpack:///./src/pug-loader/i18n.js?");

/***/ }),

/***/ "./src/pug-loader/index.js":
/*!*********************************!*\
  !*** ./src/pug-loader/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./src/pug-loader/main.css\");\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_main_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./i18n */ \"./src/pug-loader/i18n.js\");\n/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_i18n__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nwindow.i18n = _i18n__WEBPACK_IMPORTED_MODULE_1___default.a;\r\nconsole.log(_i18n__WEBPACK_IMPORTED_MODULE_1___default.a);\r\n_i18n__WEBPACK_IMPORTED_MODULE_1___default.a.add('en',{\"home name\":'Name'});\r\n_i18n__WEBPACK_IMPORTED_MODULE_1___default.a.add('cn',{\"home name\":''});\r\n_i18n__WEBPACK_IMPORTED_MODULE_1___default.a.setActiveLanguage('en');\r\nvar el= document.getElementById('home name');\r\nel.innerText = _i18n__WEBPACK_IMPORTED_MODULE_1___default.a.t('home name');\r\n// Use the same template for the frontend code\r\n// var template = require('./time.pug');\r\n\r\n// setInterval(function () {\r\n//   var div = document.getElementById('main');\r\n//   div.innerHTML = template({ time: new Date() });\r\n//   div.style.color = 'navy';\r\n// }, 1000);\r\n\n\n//# sourceURL=webpack:///./src/pug-loader/index.js?");

/***/ }),

/***/ "./src/pug-loader/main.css":
/*!*********************************!*\
  !*** ./src/pug-loader/main.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/pug-loader/main.css?");

/***/ })

/******/ });